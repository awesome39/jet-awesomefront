async= require 'async'

module.exports= (db, prefix, Model) ->

    return class Resource extends Model


        data: () ->
            data= {}
            for p in Object.keys @constructor.properties
                data[p]= @[p] if @[p]?
            return data


        @db: db
        @prefix: prefix



        @id: (model, done) ->
            @db.incr ([@prefix,@identity].join '#'), (err, id) =>
                model[@identity]= id
                return done err, model



        @get: (id, done) ->
            console.log 'получить модель', id
            @db.hgetall ([@prefix,id].join ':'), (err, data) =>
                return done err if err
                return done 'not data' if not data
                try
                    model= new @ data
                    model[@identity]= id
                    return done err, model
                catch err
                    return done err



        @put: (model, done) ->
            id= model[@identity]
            data= do model.data
            console.log 'положить модель', data
            multi= do @db.multi
            async.map (Object.keys data) # обновление индексов
            ,   (k, done) =>
                    index= @indexies[k]
                    return do done if not index
                    if index.unique
                        value= data[k]
                        console.log value
                        multi.set ([([@prefix,k].join '@'),value].join ':'), id
                        return do done
                    else
                        return done 'not implemented'
            ,   (err) =>
                    return done err if err
                    multi.hmset ([@prefix,model[@identity]].join ':'), data
                    multi.sadd @prefix, model[@identity]
                    multi.exec (err) ->
                        return done err if err
                        return done err, model



        @del: (model, done) ->
            console.log 'удалить модель', model
            multi= do @db.multi
            multi.del ([@prefix,model[@identity]].join ':')
            multi.srem @prefix, model[@identity]
            multi.exec (err) =>
                return done err if err
                return done err, model



        @find: (id, done) ->
            @db.sismember @prefix, id, (err, exists) =>
                return done err if err
                return done err, null if not exists

                @get id, done

        @find.Error= class FindError


        ###
        Ищет модель по указанному индексу
        ###
        @findBy: (index, value, done) ->
            @db.get ([([@prefix,index].join '@'),value].join ':'), (err, id) =>
                return done err if err
                return done err, null if not id

                @get id, done



        ###
        Запращивает список моделей
        ###
        @query: (query, done) ->

            @db.sort @prefix, 'by', 'nosort', (err, keys) =>
                return done err if err

                res= []
                async.reduce keys, res

                ,   (models, key, done) =>
                        @get key, (err, model) =>
                            return done null, models if err == 'not data'
                            models.push model
                            return done err, models

                ,   (err, models) =>
                        return done err if err
                        return done err, models

        @query.Error= class QueryError



        ###
        Сохраняет новую модель
        ###
        @create: (data, done) ->
            @validate data, (err, data) =>
                return done new @create.ValidateError err if err and err instanceof @ValidateError

                @validateIndexies data, (err) =>
                    return done new @create.ValidateError err if err and err instanceof @ValidateError

                    model= new @ data
                    @id model, (err, model) =>
                        return done err if err

                        model.createdAt= new Date().getTime()

                        console.log 'модель перед сохранением', model
                        @put model, done

        @create.Error= class CreateError
        @create.ValidateError= class CreateValidateError extends @create.Error
            constructor: (err) ->
                @errors= err.errors



        ###
        Обновляет существующую модель
        ###
        @update: (key, data, done) ->
            @find key, (err, model) =>
                return done err if err
                return done new @update.NotFoundError if not model

                dirty= {}
                (Object.keys @properties).map (k) ->
                    dirty[k]= data[k] if model[k] != data[k]

                @validateIndexies dirty, (err) =>
                    return done new @update.ValidateError err if err and err instanceof @ValidateError

                    model.init dirty
                    @validate model, (err) =>
                        return done new @update.ValidateError err if err and err instanceof @ValidateError

                        model.updatedAt= new Date().getTime()

                        console.log 'модель перед обновлением', model
                        @put model, done

        @update.Error= class UpdateError
        @update.NotFoundError= class UpdateNotFoundError extends @update.Error
        @update.ValidateError= class UpdateValidateError extends @update.Error
            constructor: (err) ->
                @errors= err.errors


        ###
        Удаляет существующую модель
        ###
        @delete: (key, done) ->
            @find key, (err, model) =>
                return done err if err
                return done new @delete.NotFoundError if not model

                model.deletedAt= new Date().getTime()

                console.log 'модель перед удалением', model
                @del model, done

        @delete.Error= class DeleteError
        @delete.NotFoundError= class DeleteNotFoundError extends @delete.Error



        ###
        Проверяет индексы данных модели
        ###
        @validateIndexies: (data, done) ->
            async.map (Object.keys data)

            ,   (i, done) =>
                    index= @indexies[i]
                    return do done if not index
                    return do done if not index.unique
                    @findBy i, data[i], (err, found) =>
                        return done err if err
                        return done new @validateIndexies.ExistsError i, data[i] if found
                        return do done

            ,   (err) =>
                    return done err, data

        @validateIndexies.ExistsError= class ValidateExistsError extends @ValidateError
            constructor: (property, value) ->
                @errors= {}
                @errors[property]=
                    value: value
                    error: 'Exists'
